<polymer-element name="pwr-deck" attributes="current" constructor="PwrDeck" on-mouseover="{{keyControlsOn}}" on-mouseout="{{keyControlsOff}}">
	<template>
		<style type="text/css">
			:host {
			  display: block;
			  overflow: hidden;
			  position: relative;
			  -webkit-transition: opacity 800ms ease-in;
			  -webkit-transition-delay: 100ms;
			  -moz-transition: opacity 800ms ease-in 100ms;
			  -o-transition: opacity 800ms ease-in 100ms;
			  transition: opacity 800ms ease-in 100ms;
			}

			:host(:host:-webkit-full-screen) {
				width: 100%;
				height: 100%;
				font-size: 1.5vw;
			}
		</style>
		<content id="slides" select="pwr-slide"></content>
	</template>
	<script>
		(function() {
			var SLIDE_CLASSES_ 	= ['far-past', 'past', 'current', 'next', 'far-next'],
					PREFIXES_ 			= ["webkit", "moz", "MS", "o", ""],
					prevSlide_ 			= 0,

					// TODO:
					// Fix fullscreen mode
					onKeyDown_			= function(e) {
					  if (/^(input|textarea)$/i.test(e.target.nodeName) ||
					      e.target.isContentEditable || !this.controlsActive) {
					    return;
					  }

						switch (e.keyCode) {
					    case 39: // right arrow
					    case 32: // space
					    case 34: // PgDn
					    case 40: // down arrow
					      this.nextSlide();
					      e.preventDefault();
					      break;

					    case 37: // left arrow
					    case 33: // PgUp
					    case 38: // up arrow
					      this.prevSlide();
					      e.preventDefault();
					      break;

						  case 70: // F: Toggle fullscreen
					      if (!(e.shiftKey && e.metaKey)) {
					        if (this.mozRequestFullScreen) {
					        	this.mozRequestFullScreen();
					        } else if (this.webkitRequestFullScreen) {
					          this.webkitRequestFullScreen();
					        }
					      }
					      break;
					  }
				},

				addPrefixedListeners_ = function(elem, type, callback) {
					for (var i = PREFIXES_.length - 1; i >= 0; i--) {
						elem.addEventListener(PREFIXES_[i]+type, callback, false);					
					}
				},

				addEventListeners_ = function() {
					document.addEventListener('keydown', onKeyDown_.bind(this), false);
					this.addEventListener('animationend', handleAnimated_.bind(this), false); // moz workaround
					addPrefixedListeners_(this, 'AnimationEnd', handleAnimated_.bind(this));
				},

				handleAnimated_ = function(e) {
					if (e.target instanceof PwrAnimated) {
						var el = e.target;
						e.stopPropagation();
						// Exit animation actions
						if (e.animationName === el.exit) {
							if (el.nodeName === "PWR-SLIDE") {
								this.getSlide(this.curslide).animateIn();
								updateSlides_.call(this);
							}

						// Entrance animation actions
						} else if (e.animationName === el.entrance) {

							// onentry callback called after animation ends
							// NOTE: onexit callback called before exit animation begins
							// (see PwrAnimated)
							if (el.onentry) {
								new Function(el.onentry)();	
							}
						}
					}
				},

				// TODO:
				// trigger slide events
				// enable iframe preloading
				// add support for overview mode
				updateSlides_ 		= function() {
					var curslide 					= this.curslide,
							updateSlideClass	= updateSlideClass_.bind(this);
					for (var i = 0; i < this.totalSlides; ++i) {
						switch(i) {
							case curslide - 2:
								updateSlideClass(i, 'far-past');
								break;
							case curslide - 1:
								updateSlideClass(i, 'past');
								break;
				      case curslide:
				        updateSlideClass(i, 'current');
				        break;
				      case curslide + 1:
				        updateSlideClass(i, 'next');
				        break;
				      case curslide + 2:
				        updateSlideClass(i, 'far-next');
				        break;
				      default:
				        updateSlideClass(i);
				        break;							
						}
					}
				},

				updateSlideClass_ = function(slideNum, className) {
					var slide = this.getSlide(slideNum);

					if (!slide) {
						return;
					}

					if (className) {
						slide.setAttribute(className, "");
					}

					for (var i = 0, slideClass; slideClass = SLIDE_CLASSES_[i]; ++i) {
						if (className != slideClass) {
							slide.removeAttribute(slideClass);
						}
					}
				};

			Polymer('pwr-deck', {
				current: 1,
				curslide: 0,
				controlsActive: false,
				publish: {
					totalSlides: 0
				},

				currentChanged: function(oldVal, newVal) {
					// Prevents the initial slide transition on load (since this is the
					// only time prevSlide_ and curslide are both falsey 0)
					if (newVal > 0 && newVal <= this.totalSlides) {
						this.loadSlide(newVal - 1);
					} 
				},

				ready: function() {
					this.slides = this.$.slides.getDistributedNodes();
					this.totalSlides = this.slides.length;

					addEventListeners_.call(this);
					updateSlides_.call(this);
				},

				keyControlsOff: function(e) {
					e.stopPropagation();
					this.controlsActive = false;
				},

				keyControlsOn: function(e) {
					e.stopPropagation();
					this.controlsActive = true;
				},

				// TODO:
				// Add overview support
				nextSlide: function() {
					if (this.getSlide(this.curslide).animateNextPiece()) {
						return;
					}

					if (this.current < this.totalSlides) {
						this.current++;
					}
				},

				prevSlide: function() {
					if (this.current > 1) {
						this.current--;
					}
				},

				getSlide: function(slideNum) {
					if ((slideNum < 0) || (slideNum >= this.totalSlides)) {
						return null;
					} else {
						return this.slides[slideNum];
					}
				},

				loadSlide: function(slideNum) {
					if ((slideNum < 0) || (slideNum >= this.totalSlides)) {
						return null;
					} else {
						prevSlide_ = this.curslide;
						this.curslide = slideNum;
						this.fire('slidechange', {curslide: this.curslide});
						this.getSlide(prevSlide_).animateOut();
					}
				}
			});
		})()
	</script>
</polymer-element>