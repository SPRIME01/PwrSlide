<link rel="import" href="pwr-animated.html">
<polymer-element extends="pwr-animated" name="pwr-slide" constructor="PwrSlide">
	<template>
		<style type="text/css">
			:host{
			  position: relative;
			  top: 0;
			  left: 0;
			  overflow: hidden;
			  display: none;
  			width: 100%;
				height: 100%;
				margin: 0;
				-moz-transition: opacity 800ms ease-in 100ms;
			  -o-transition: opacity 800ms ease-in 100ms;
			  transition: opacity 800ms ease-in 100ms;
			  -webkit-box-sizing: border-box;
			  -moz-box-sizing: border-box;
			  box-sizing: border-box;	
			  -webkit-animation: 1s both;
			  animation: 1s both;
			  -webkit-animation-name: {{ animationName }} !important;
			  animation-name: {{ animationName }} !important; 
		  }

			:host[past] {
			  /*opacity: 0;*/
			}

			:host(:host[current]) {
			  display: block;
			}

			:host[next] {
			  pointer-events: none;
			}
		</style>
		<content id="content"></content>
	</template>
	<script type="text/javascript">
		(function() {
			var collectAnimationPieces_ = function() {
					this.animateInPieces = [].filter.call(
						this.pieces, function(el) {
							return typeof el.entrance === "string";
						});
					this.animateOutPieces = [].filter.call(
						this.pieces, function(el) {
							return typeof el.exit === "string";
						});
				};

			Polymer('pwr-slide', {
				entrance: "fadeIn", 
				exit: "fadeOut",

				animatePiece: function(p) {
					var piece, i;
					
					// Collect animateIn/animateOut pieces on the first call
					if (!this.animateInPieces || !this.animateOutPieces) {
						collectAnimationPieces_.call(this);
					}

					if (typeof p === "number") {
						piece = this.pieces[p];
					} else if (!![].indexOf.call(this.pieces, p)) {
						piece = p;
					} else {
						return null;
					}

					if (typeof arguments[1] === "string" && arguments[1].toLowerCase() === "out") {
						i = this.animateOutPieces.indexOf(piece);
						piece = this.animateOutPieces.splice(i, 1)[0];
						piece.animateOut();
					} else {
						i = this.animateInPieces.indexOf(piece);
						piece = this.animateInPieces.splice(i, 1)[0];
						piece.animateIn();
					}
					return piece;
				},

				animateNextPiece: function() {
					// Collect animateIn/animateOut pieces on the first call
					if (!this.animateInPieces || !this.animateOutPieces) {
						collectAnimationPieces_.call(this);
					}

					if (this.curPiece = this.animateInPieces.shift()) {
						this.curPiece.animateIn();
						return true;
					} else if (this.curPiece = this.animateOutPieces.shift()) {
						this.curPiece.animateOut();
						return true;
					} else {
						[].map.call(this.pieces, function(el) {
							el.removeAnimations();
						});
						return false;
					}
				},

				ready: function() {
					this.pieces = this.querySelectorAll('[is="pwr-piece"], pwr-piece')
				},
			});
		})();
	</script>
</polymer-element>